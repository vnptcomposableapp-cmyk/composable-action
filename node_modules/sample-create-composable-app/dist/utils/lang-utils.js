"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.AssertionError = void 0;
exports.flatMap = flatMap;
exports.ensure = ensure;
exports.ensureString = ensureString;
exports.assert = assert;
/*eslint
@typescript-eslint/no-explicit-any: 0,
@typescript-eslint/explicit-module-boundary-types: 0,
no-debugger: 0,
*/
const lodash_1 = __importDefault(require("lodash"));
function flatMap(arr, f) {
    const r = [];
    for (const x of arr) {
        r.push(...f(x));
    }
    return r;
}
function ensure(x, msg = '') {
    if (x === null || x === undefined) {
        debugger;
        msg = (lodash_1.default.isString(msg) ? msg : msg()) || '';
        throw new Error(`Value must not be undefined or null${msg ? `- ${msg}` : ''}`);
    }
    else {
        return x;
    }
}
function ensureString(x) {
    if (lodash_1.default.isString(x)) {
        return x;
    }
    else {
        throw new Error(`Expected ${x} to be a string`);
    }
}
class AssertionError extends Error {
    constructor(msg = 'Assertion failed') {
        super(msg);
    }
}
exports.AssertionError = AssertionError;
function assert(cond, msg = 'Assertion failed') {
    if (!cond) {
        // We always generate an non empty message so that it doesn't get swallowed
        // by the async library.
        msg = (lodash_1.default.isString(msg) ? msg : msg()) || 'Assertion failed';
        debugger;
        throw new AssertionError(msg);
    }
}
