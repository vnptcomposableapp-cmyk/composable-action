"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.tanstackStrategy = void 0;
const fs_1 = require("fs");
const path_1 = __importDefault(require("path"));
const cmd_utils_1 = require("../utils/cmd-utils");
const codegen_1 = require("../utils/codegen");
const file_utils_1 = require("../utils/file-utils");
const npm_utils_1 = require("../utils/npm-utils");
const plasmic_host_1 = require("./templates/file-router/plasmic-host");
const root_1 = require("./templates/file-router/root");
exports.tanstackStrategy = {
    create: (args) => __awaiter(void 0, void 0, void 0, function* () {
        const { projectPath } = args;
        /* create-tsrouter-app package receives the projectName as an argument, when we provide a fullProjectPath, it creates
        package.json with name having the fullProjectPath causing illegal characters in the name field error.
    
          To avoid this behaviour, we will ensure the fullProjectPath exists
          1. we get the projectName (tanstack-codegen-ts), and parentDir (/private/tmp/cpa-out)
          2. change directory to parentDir and execute the command with projectName
         */
        const fullProjectPath = path_1.default.isAbsolute(projectPath)
            ? projectPath
            : path_1.default.resolve(process.cwd(), projectPath);
        yield fs_1.promises.mkdir(fullProjectPath, { recursive: true });
        const projectName = path_1.default.basename(fullProjectPath);
        const parentDir = path_1.default.dirname(fullProjectPath);
        process.chdir(parentDir);
        const createCommand = `npx create-tsrouter-app@latest ${projectName} --template file-router --add-ons start`;
        yield (0, cmd_utils_1.spawnOrFail)(createCommand);
        // Install peer-dep of @tanstack/react-router-with-query
        yield (0, npm_utils_1.installUpgrade)('@tanstack/react-query', {
            workingDir: projectPath,
        });
    }),
    installDeps: (_a) => __awaiter(void 0, [_a], void 0, function* ({ scheme, projectPath }) {
        if (scheme === 'loader') {
            throw new Error('Plasmic loader scheme is not supported for TanStack platform. Please use the codegen scheme instead.');
        }
        else {
            return yield (0, codegen_1.installCodegenDeps)({ projectPath });
        }
    }),
    overwriteConfig: (args) => __awaiter(void 0, void 0, void 0, function* () {
        const { projectPath } = args;
        // Add @plasmicapp/* packages in noExternal to work during SSR
        const viteConfigPath = path_1.default.join(projectPath, 'vite.config.ts');
        const viteConfigContent = yield fs_1.promises.readFile(viteConfigPath, 'utf8');
        yield fs_1.promises.writeFile(viteConfigPath, viteConfigContent.replace('defineConfig({', `defineConfig({
  ssr: {
    noExternal: [
      "@plasmicapp/data-sources",
      "@plasmicapp/data-sources-context",
      "@plasmicapp/prepass",
      "@plasmicapp/query",
      "@plasmicapp/react-web",
    ],
  },`));
        // Disable verbatimModuleSyntax in tsconfig.json
        const tsconfigPath = path_1.default.join(projectPath, 'tsconfig.json');
        const tsconfigContent = yield fs_1.promises.readFile(tsconfigPath, 'utf8');
        yield fs_1.promises.writeFile(tsconfigPath, tsconfigContent.replace('"verbatimModuleSyntax": true', '"verbatimModuleSyntax": false'));
    }),
    generateFiles: (args) => {
        return generateFilesFileRouterTemplate(args);
    },
    build: (args) => __awaiter(void 0, void 0, void 0, function* () {
        const { npmRunCmd, projectPath } = args;
        yield (0, cmd_utils_1.spawnOrFail)(`${npmRunCmd} build`, projectPath);
    }),
};
function generateFilesFileRouterTemplate(args) {
    return __awaiter(this, void 0, void 0, function* () {
        const { projectPath, scheme, projectId, projectApiToken } = args;
        // Delete existing pages
        (0, file_utils_1.deleteGlob)(path_1.default.join(projectPath, 'src/routes', '*.*'));
        if (scheme === 'loader') {
            throw new Error('Plasmic loader scheme is not supported for TanStack platform. Please use the codegen scheme instead.');
        }
        else {
            // ./src/routes/__root.tsx
            yield fs_1.promises.writeFile(path_1.default.join(projectPath, 'src/routes', '__root.tsx'), (0, root_1.makeCustomRoot_file_router_codegen)());
            // ./src/routes/plasmic-host.tsx
            yield fs_1.promises.writeFile(path_1.default.join(projectPath, 'src/routes', 'plasmic-host.tsx'), (0, plasmic_host_1.makePlasmicHostPage_fileRouter_codegen)());
            // This should generate
            // ./plasmic.json
            // ./routes/index.tsx
            // ./components/plasmic/**
            yield (0, codegen_1.runCodegenSync)({
                projectId,
                projectApiToken,
                projectPath,
            });
        }
    });
}
