import socketio from "socket.io-client";
import { AuthConfig, CodeConfig, CustomFunctionConfig, FontConfig, I18NConfig, ImagesConfig, StyleConfig } from "./utils/config-utils";
import { Metadata } from "./utils/get-context";
export declare class AppServerError extends Error {
    constructor(message: string);
}
export interface ComponentBundle {
    renderModule: string;
    skeletonModule: string;
    cssRules: string;
    renderModuleFileName: string;
    skeletonModuleFileName: string;
    cssFileName: string;
    componentName: string;
    id: string;
    scheme: "blackbox" | "plain";
    nameInIdToUuid: Array<[string, string]>;
    isPage: boolean;
    path?: string;
    plumeType?: string;
    rscMetadata?: {
        pageWrappers: Record<"client" | "server", {
            module: string;
            fileName: string;
        }>;
    };
}
export interface GlobalVariantBundle {
    id: string;
    name: string;
    contextModule: string;
    contextFileName: string;
}
export interface GlobalContextBundle {
    id: string;
    contextModule: string;
}
export interface SplitsProviderBundle {
    id: string;
    module: string;
}
export interface StyleTokensProviderBundle {
    id: string;
    module: string;
}
export interface ProjectModuleBundle {
    id: string;
    module: string;
}
export interface JsBundleTheme {
    themeFileName: string;
    themeModule: string;
    bundleName: string;
}
export interface ProjectMetaBundle {
    projectId: string;
    projectName: string;
    cssFileName: string;
    cssRules: string;
    globalContextBundle?: GlobalContextBundle;
    splitsProviderBundle?: SplitsProviderBundle;
    styleTokensProviderBundle?: StyleTokensProviderBundle;
    projectModuleBundle?: ProjectModuleBundle;
    reactWebExportedFiles?: Array<{
        fileName: string;
        content: string;
    }>;
}
export interface IconBundle {
    id: string;
    name: string;
    module: string;
    fileName: string;
}
export interface ImageBundle {
    id: string;
    name: string;
    blob: string;
    fileName: string;
}
export interface ProjectVersionMeta {
    projectId: string;
    branchName: string;
    projectApiToken: string;
    version: string;
    projectName: string;
    componentIds: string[];
    dependencies: {
        [projectId: string]: string;
    };
    indirect: boolean;
}
export interface VersionResolution {
    projects: ProjectVersionMeta[];
    dependencies: ProjectVersionMeta[];
    conflicts: ProjectVersionMeta[];
}
export interface RequiredPackages {
    "@plasmicapp/loader": string;
    "@plasmicapp/cli": string;
    "@plasmicapp/host": string;
    "@plasmicapp/react-web": string;
    "@plasmicapp/react-web-runtime": string;
}
export interface ProjectMetaInfo {
    id: string;
    name: string;
    workspaceId?: string;
    hostUrl?: string;
    lastPublishedVersion?: string;
}
export interface ProjectBundle {
    components: ComponentBundle[];
    codeComponentMetas: CodeComponentMeta[];
    customFunctionMetas: CustomFunctionConfig[];
    projectConfig: ProjectMetaBundle;
    globalVariants: GlobalVariantBundle[];
    usedTokens: StyleTokensMap;
    iconAssets: IconBundle[];
    imageAssets: ImageBundle[];
    checksums: ChecksumBundle;
    usedNpmPackages: string[];
    externalCssImports: string[];
}
export type ProjectMeta = Omit<ProjectBundle, "projectConfig">;
export interface StyleConfigResponse {
    defaultStyleCssFileName: string;
    defaultStyleCssRules: string;
}
export interface StyleTokensMap {
    props: {
        name: string;
        type: string;
        value: string | number;
        meta: {
            projectId: string;
            id: string;
        };
    }[];
    global: {
        meta: {
            source: "plasmic.app";
        };
    };
}
export interface ChecksumBundle {
    renderModuleChecksums: Array<[string, string]>;
    cssRulesChecksums: Array<[string, string]>;
    imageChecksums: Array<[string, string]>;
    iconChecksums: Array<[string, string]>;
    globalVariantChecksums: Array<[string, string]>;
    projectCssChecksum: string;
    globalContextsChecksum: string;
    splitsProviderChecksum: string;
    styleTokensProviderChecksum: string;
    projectModuleChecksum: string;
}
export interface CodeComponentMeta {
    id: string;
    name: string;
    displayName: string;
    importPath: string;
    helper?: {
        name: string;
        importPath: string;
    };
}
export interface ProjectIconsResponse {
    version: string;
    icons: IconBundle[];
}
export interface ProjectIdAndToken {
    projectId: string;
    projectApiToken?: string;
}
export declare class PlasmicApi {
    private auth;
    private codegenVersion?;
    constructor(auth: AuthConfig);
    genStyleConfig(styleOpts?: StyleConfig): Promise<StyleConfigResponse>;
    /**
     * Sync resolution - Given a fuzzy idea of what the user wants,
     * (i.e. a versionRange and component names),
     * ask the server for the exact references for a later call to `projectComponents`
     * - For components specified in the parameters - the server will return the latest version that satisfies the versionRange
     * - Any conflicting versions will be returned in `conflicts`, and should cause the client's sync to abort
     * @param projects
     * @param recursive
     */
    resolveSync(projects: {
        projectId: string;
        branchName: string;
        versionRange?: string;
        componentIdOrNames: readonly string[] | undefined;
        projectApiToken?: string;
    }[], recursive?: boolean): Promise<VersionResolution>;
    getCurrentUser(): Promise<import("axios").AxiosResponse<any>>;
    requiredPackages(): Promise<RequiredPackages>;
    latestCodegenVersion(): Promise<string>;
    /**
     * Code-gen endpoint.
     * This will fetch components from a given branch at an exact specified version.
     * If you don't know what version should be used, call `resolveSync` first.
     * @param projectId
     * @param branchName
     * @param cliVersion
     * @param reactWebVersion
     * @param newCompScheme
     * @param existingCompScheme
     * @param componentIdOrNames
     * @param version
     */
    projectComponents(projectId: string, branchName: string, opts: {
        platform: string;
        platformOptions: {
            nextjs?: {
                appDir: boolean;
            };
        };
        componentIdOrNames: readonly string[] | undefined;
        version: string;
        imageOpts: ImagesConfig;
        fontOpts?: FontConfig;
        stylesOpts: StyleConfig;
        i18nOpts?: I18NConfig;
        codeOpts: CodeConfig;
        checksums: ChecksumBundle;
        indirect: boolean;
        wrapPagesWithGlobalContexts: boolean;
        metadata?: Metadata;
    }): Promise<ProjectBundle>;
    /**
     * Code-gen endpoint.
     * This will fetch components from a given branch at an exact specified version
     * using the "plain" scheme
     */
    exportProject(projectId: string, branchName: string, opts: {
        platform: string;
        platformOptions: {
            nextjs?: {
                appDir: boolean;
            };
        };
        version: string;
        imageOpts: ImagesConfig;
        stylesOpts: StyleConfig;
        i18nOpts?: I18NConfig;
        codeOpts: Pick<CodeConfig, "lang">;
        indirect: boolean;
        wrapPagesWithGlobalContexts: boolean;
        metadata?: Metadata;
    }): Promise<ProjectBundle>;
    projectMeta(projectId: string): Promise<ProjectMetaInfo>;
    genLocalizationStrings(projects: readonly string[], format: "po" | "json" | "lingui", keyScheme: "content" | "hash" | "path", tagPrefix: string | undefined, projectIdsAndTokens: ProjectIdAndToken[], excludeDeps: boolean | undefined): Promise<string>;
    uploadBundle(projectId: string, bundleName: string, bundleJs: string, css: string[], metaJson: string, genModulePath: string | undefined, genCssPaths: string[], pkgVersion: string | undefined, extraPropMetaJson: string | undefined, themeProviderWrapper: string | undefined, themeModule: string | undefined): Promise<StyleTokensMap>;
    projectStyleTokens(projectId: string, branchName: string, versionRange?: string): Promise<StyleTokensMap>;
    projectIcons(projectId: string, branchName: string, versionRange?: string, iconIds?: string[]): Promise<ProjectIconsResponse>;
    connectSocket(): ReturnType<typeof socketio>;
    private post;
    private get;
    private makeErrorMessage;
    private makeHeaders;
    private projectIdsAndTokens?;
    attachProjectIdsAndTokens(idsAndTokens: ProjectIdAndToken[]): void;
    private get studioHost();
    private get codegenHost();
}
